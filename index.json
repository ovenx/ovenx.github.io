[{"content":"gomod 开启 gomod 1.13 以前\nGO111MODULE=on GOPROXY=https://goproxy.io 1.13 以后\ngo env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct go get 使用 go get -u # 升级包版本 go get -u=path # 升级到最新的修订版 go get package@version # 升级到某个版本 go mod 基本操作 go mod init mod_name ## 初始化 mod go mod download ## 下载 mod 到本地 cache $GOPATH/pkg/mod 和 $GOPATH/pkg/sum下 go mod edit # 编辑 go.mod 文件 go mod tidy # 删除不使用的 mod go mod vendor # 生成 vendor 目录 go mod verify # 验证依赖 go mod why # 查找依赖 go clean --modcache # 清楚 module 缓存 格式化整个项目代码 gofmt -s -w -l . build 不同平台 Mac 下编译 Linux, Windows 平台的 64 位可执行程序：\nCGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o output_name main.go CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build` main.go Linux 下编译 Mac, Windows平台的 64 位可执行程序：\nCGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build main.go CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build` main.go Windows 下编译 Mac, Linux 平台的 64 位可执行程序：\nSET CGO_ENABLED=0 SET GOOS=darwin3 GOARCH=amd64 go build main.go SET CGO_ENABLED=0 SET GOOS=linux GOARCH=amd64 go build main.go ","permalink":"https://blog.ovenx.cn/post/go-tips/","summary":"gomod 开启 gomod 1.13 以前\nGO111MODULE=on GOPROXY=https://goproxy.io 1.13 以后\ngo env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct go get 使用 go get -u # 升级包版本 go get -u=path # 升级到最新的修订版 go get package@version # 升级到某个版本 go mod 基本操作 go mod init mod_name ## 初始化 mod go mod download ## 下载 mod 到本地 cache $GOPATH/pkg/mod 和 $GOPATH/pkg/sum下 go mod edit # 编辑 go.mod 文件 go mod tidy # 删除不使用的 mod go mod vendor # 生成 vendor 目录 go mod verify # 验证依赖 go mod why # 查找依赖 go clean --modcache # 清楚 module 缓存 格式化整个项目代码 gofmt -s -w -l .","title":"Go Tips"},{"content":"修改 ssh 22 端口 vi /etc/ssh/sshd_config Port xxxx sysemctl restart sshd 修改 git 对应端口 vi /.git/config\nurl = ssh://git@server:xxxx/root/test.git rsync 指定端口\nrsync -e \u0026#39;ssh -p xxxx\u0026#39; ssh 指定端口\nssh -p xxxx root@server \u0026#34;systemctl restart heepark\u0026#34; 修改 MySQL 3306 端口 vi /etc/my.cnf.d/server.cnf [mysqld] port=xxxx systemctl restart mariadb ","permalink":"https://blog.ovenx.cn/post/modify-ports/","summary":"修改 ssh 22 端口 vi /etc/ssh/sshd_config Port xxxx sysemctl restart sshd 修改 git 对应端口 vi /.git/config\nurl = ssh://git@server:xxxx/root/test.git rsync 指定端口\nrsync -e \u0026#39;ssh -p xxxx\u0026#39; ssh 指定端口\nssh -p xxxx root@server \u0026#34;systemctl restart heepark\u0026#34; 修改 MySQL 3306 端口 vi /etc/my.cnf.d/server.cnf [mysqld] port=xxxx systemctl restart mariadb ","title":"修改常用端口"},{"content":"新建 systemd 文件 在 /etc/systemd/system/ 目录下新建service example.servie\n[Unit] Description=example [Service] Type=simple Restart=always RestartSec=5 ExecStart=/www/example/main # 可执行文件的路径 ExecReload=/bin/kill -HUP $MAINPID PIDFile=/var/run/example.pid # pid file WorkingDirectory=/www/example [Install] WantedBy=multi-user.target 重新加载配置文件\nsystemctl daemon-reload 常用操作\nsystemctl start example systemctl restart example # 重启 systemctl enable example # 添加自启动 配置 nginx 代理 server { server_name example.com; listen 443 http2 ssl; listen [::]:443 http2 ssl; ssl_certificate /etc/letsencrypt/live/example.cn/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/example.cn/privkey.pem; include /etc/nginx/default.d/ssl.conf; root /www/example; index index.html; location / { proxy_pass http://127.0.0.1:4000; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } # redirect to https server { server_name example.com; listen 80; listen [::]:80; include /etc/nginx/default.d/letsencrypt.conf; location / { return 301 https://$host$request_uri; } } 部署脚本 新建 deploy.sh\n#!/bin/sh echo \u0026#34;Step 1: building ...\u0026#34; CGO\\_ENABLED\\=0 GOOS\\=linux GOARCH\\=amd64 go build \\-ldflags\\=\u0026#34;-s -w\u0026#34; main.go echo \u0026#34;Step 2: Uploading ...\u0026#34; rsync \\-zp --progress main root@server:/www/example/main echo \u0026#34;Step 3: Restarting ...\u0026#34; ssh root@server \u0026#34;systemctl restart example\u0026#34; ","permalink":"https://blog.ovenx.cn/post/go-deploy/","summary":"新建 systemd 文件 在 /etc/systemd/system/ 目录下新建service example.servie\n[Unit] Description=example [Service] Type=simple Restart=always RestartSec=5 ExecStart=/www/example/main # 可执行文件的路径 ExecReload=/bin/kill -HUP $MAINPID PIDFile=/var/run/example.pid # pid file WorkingDirectory=/www/example [Install] WantedBy=multi-user.target 重新加载配置文件\nsystemctl daemon-reload 常用操作\nsystemctl start example systemctl restart example # 重启 systemctl enable example # 添加自启动 配置 nginx 代理 server { server_name example.com; listen 443 http2 ssl; listen [::]:443 http2 ssl; ssl_certificate /etc/letsencrypt/live/example.cn/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/example.cn/privkey.pem; include /etc/nginx/default.d/ssl.conf; root /www/example; index index.html; location / { proxy_pass http://127.","title":"使用 Systemd 部署 Golang 应用"},{"content":"安装环境 Linux 版本： centos 7.6 PostgreSQL 版本：13 安装 postgresql sudo yum install -y https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86\\_64/pgdg-redhat-repo-latest.noarch.rpm sudo yum install -y postgresql13-server sudo /usr/pgsql-13/bin/postgresql-13-setup initdb sudo systemctl enable postgresql-13 sudo systemctl start postgresql-13 参考来源：https://www.postgresql.org/download/linux/redhat/\n添加用户和数据库 使用 psql sudo -u postgres psql # 切换为 postgres 用户登录 psql \\password # 设置默认密码 create user myuser with password \u0026#39;mypass\u0026#39;; # 添加用户 create database mydb OWNER myuser; # 添加数据库 grant all privileges on database mydb to myuser; # 添加权限 \\q # quit 使用 shell sudo -u postgres createuser --superuser myuser; # 添加用户 sudo -u postgres psql # 登录 psql 设置密码 \\password myuser \\q sudo -u postgres createdb -O myuser mydb # 添加数据库 登录数据库 本地登录 psql -h 127.0.0.1 -p 5432 mydb myuser 远程登录 修改 pg_hba.conf 配置文件， vi /var/lib/pgsql/13/data/pg_hba.conf 找到 # IPv4 local connections:，下面添加一行\nhost all all 0.0.0.0/0 scram-sha-256 修改 postgresql.conf 配置文件，vi /var/lib/pgsql/13/data/postgresql.conf\n找到 #listen_addresses = 'localhost'，打开注释，修改为\nlisten_addresses = \u0026#39;*\u0026#39; 最后重启服务即可（** 注意：如果是部署在云服务器上，需要在安全组策略中放行 5432 端口 **）\nsystemctl restart postgresql-13 常用命令 \\? # 查看所有命令 \\h # 查看 sql 命令 \\l # 查看所有数据库 \\du # 查看所有用户 \\d # 查看所有表格 \\d [table_name] # 查看某一个表格结构 \\c [database_name] # 连接其它数据库 \\conninfo # 当前连接信息 ALTER USER myuser WITH PASSWORD \u0026#39;mypass\u0026#39;; #修改密码 ","permalink":"https://blog.ovenx.cn/post/postgresql/","summary":"安装环境 Linux 版本： centos 7.6 PostgreSQL 版本：13 安装 postgresql sudo yum install -y https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86\\_64/pgdg-redhat-repo-latest.noarch.rpm sudo yum install -y postgresql13-server sudo /usr/pgsql-13/bin/postgresql-13-setup initdb sudo systemctl enable postgresql-13 sudo systemctl start postgresql-13 参考来源：https://www.postgresql.org/download/linux/redhat/\n添加用户和数据库 使用 psql sudo -u postgres psql # 切换为 postgres 用户登录 psql \\password # 设置默认密码 create user myuser with password \u0026#39;mypass\u0026#39;; # 添加用户 create database mydb OWNER myuser; # 添加数据库 grant all privileges on database mydb to myuser; # 添加权限 \\q # quit 使用 shell sudo -u postgres createuser --superuser myuser; # 添加用户 sudo -u postgres psql # 登录 psql 设置密码 \\password myuser \\q sudo -u postgres createdb -O myuser mydb # 添加数据库 登录数据库 本地登录 psql -h 127.","title":"PostgreSQL 使用教程"},{"content":"安装 wsl2 开启 wsl2\ndism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 设置默认 wsl2\nwsl --set-default-version 2 设置默认发行版\nwsl -s Ubuntu-20.04 启动和停止 wsl 服务 wsl --shutdown # net stop LxssManager 文件权限问题 由于 windows 文件系统是 NTFS, 在 wsl 在所有的文件权限都会是 777。解决方法是修改配置文件 /etc/wsl.conf\n[automount] enabled = true options = \u0026#34;metadata,umask=22,fmask=11\u0026#34; mountFsTab = false 重启后文件的权限就不再都是 777 了。\nwsl 文件在 windows 系统中的位置 可以把它映射到网络位置\n\\\\wsl$ 设置默认 root 登录 debian config --default-user root 修改 wsl 位置 关闭 wsl\nwsl --shutdown 查看系统\nwsl -l -v 导出系统\nwsl --export Debian D:\\ubuntu.tar 删除原有系统\nwsl --unregister Ubuntu-20.04 导入新新系统\nwsl --import Ubuntu-20.04 D:\\ubuntu D:\\ubuntu.tar wsl -l -v wsl 自启动服务 创建开机脚本 /root/init.wsl\n#! /bin/sh /etc/init.d/nginx start /etc/init.d/php7.4-fpm start /etc/init.d/redis-server start 添加权限\nchmod +x /root/init.wsl windwos 下编写 vbs 文件 start-wsl.vbs\nSet ws = WScript.CreateObject(\u0026#34;WScript.Shell\u0026#34;) ws.run \u0026#34;wsl -u root /root/init.wsl\u0026#34; 加入 windows 启动项\nwin+R shell:startup 将 start-wsl.vbs 移动在启动文件夹中\n","permalink":"https://blog.ovenx.cn/post/wsl2-config/","summary":"安装 wsl2 开启 wsl2\ndism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 设置默认 wsl2\nwsl --set-default-version 2 设置默认发行版\nwsl -s Ubuntu-20.04 启动和停止 wsl 服务 wsl --shutdown # net stop LxssManager 文件权限问题 由于 windows 文件系统是 NTFS, 在 wsl 在所有的文件权限都会是 777。解决方法是修改配置文件 /etc/wsl.conf\n[automount] enabled = true options = \u0026#34;metadata,umask=22,fmask=11\u0026#34; mountFsTab = false 重启后文件的权限就不再都是 777 了。\nwsl 文件在 windows 系统中的位置 可以把它映射到网络位置\n\\\\wsl$ 设置默认 root 登录 debian config --default-user root 修改 wsl 位置 关闭 wsl","title":"WSL2 常见问题"},{"content":"提交 pull request 的最佳实践 1. 首先 fork 仓库 添加一个自己的仓库副本\n2. 添加 upstream source git remote add upstrem URL 3. 创建一个 dev 分支 git checkout -b dev git commit -m \u0026#34;add new feature\u0026#34; 4. 开发及测试完成后 Rebase git fetch upstream git rebase upstream/master 5. 推送本地开发分支 git push origin dev 6. 发起 pull request 在 github 上发起 pull request，选择 dev 分支，填好对应的 description\nGit回滚代码到某个 commit 回退命令：\ngit reset --hard HEAD^ #回退到上个版本 git reset --hard HEAD~3 #回退到前 3 次提交之前，以此类推，回退到 n 次提交之前 git reset --hard commit_id #退到/进到指定 commit 回退版本后直接 push 会出错，需要使用 \u0026ndash;force 强制 push\ngit push origin master --force clone 某个分支 git clone -b branch 合并多个 commit git rebase -i commit_id # 会合并此次提交之后所有的提交为一个提交 git rebase -i commit_1 commit_2 # 会合 commit_1 到 commit_2 之间的记录 不包含 commit_1 包含 commit_2 git rebase -i HEAD~3 # 合并最近的 3 个 commit git rebase --continue # 解决冲突后，继续执行 rebase git rebase --abort # 终止合并 常用的 commit 操作命令\npick：保留该commit（缩写:p） reword：保留该commit，但我需要修改该commit的注释（缩写:r） edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e） squash：将该commit和前一个commit合并（缩写:s） fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f） exec：执行shell命令（缩写:x） drop：我要丢弃该commit（缩写:d） 合并 commit 后需要使用 \u0026ndash;force 强制 push 到远程\ngit push origin master --force 取消本地文件 track git rm -r --cached . # 取消所有文件的跟踪，保留文件 git rm -r --f . # 取消所有文件的跟踪，删除本地文件 git rm --cached test.file # 取消 test.file 的跟踪，保留文件 git rm --f test.file # 取消 test.file 的跟踪，删除本地文件 添加 test.file 到 .gitignore 之后提交\n","permalink":"https://blog.ovenx.cn/post/git-notes/","summary":"提交 pull request 的最佳实践 1. 首先 fork 仓库 添加一个自己的仓库副本\n2. 添加 upstream source git remote add upstrem URL 3. 创建一个 dev 分支 git checkout -b dev git commit -m \u0026#34;add new feature\u0026#34; 4. 开发及测试完成后 Rebase git fetch upstream git rebase upstream/master 5. 推送本地开发分支 git push origin dev 6. 发起 pull request 在 github 上发起 pull request，选择 dev 分支，填好对应的 description\nGit回滚代码到某个 commit 回退命令：\ngit reset --hard HEAD^ #回退到上个版本 git reset --hard HEAD~3 #回退到前 3 次提交之前，以此类推，回退到 n 次提交之前 git reset --hard commit_id #退到/进到指定 commit 回退版本后直接 push 会出错，需要使用 \u0026ndash;force 强制 push","title":"Git 常用操作笔记"},{"content":"Git 编码设置 git config --global i18n.commit.encoding utf-8 git config --global i18n.logoutputencoding utf-8 添加环境变量 设置环境变量 LESSCHARSET 为 utf-8\n","permalink":"https://blog.ovenx.cn/post/windows-terminal-git-encode/","summary":"Git 编码设置 git config --global i18n.commit.encoding utf-8 git config --global i18n.logoutputencoding utf-8 添加环境变量 设置环境变量 LESSCHARSET 为 utf-8","title":"Windows Terminal 下 git log / diff 中文乱码问题"},{"content":"开启 Adminstrator 账户 选择 计算机 -\u0026gt; 管理 -\u0026gt;本地用户和组 -\u0026gt; 用户\n找到 Administrator, 去除 此账户已禁用 勾选\n获取超级管理员权限 打开策略编辑器\nwin + r gpedit.msc 选择 计算机配置 -\u0026gt; Windows 设置 -\u0026gt; 安全策略 -\u0026gt; 本地策略 -\u0026gt; 安全选项\n找到下面两项，设置为 禁止\n用户账户控制：以管理员批准模式运行所有管理员 用户账户控制：用于内置管理员账户的管理员批准模式 重新启动后 administator 账户即可获得最高权限\n此方法只适用于 win10 专业版/教育版/企业版\n","permalink":"https://blog.ovenx.cn/post/win10-admin-permission/","summary":"开启 Adminstrator 账户 选择 计算机 -\u0026gt; 管理 -\u0026gt;本地用户和组 -\u0026gt; 用户\n找到 Administrator, 去除 此账户已禁用 勾选\n获取超级管理员权限 打开策略编辑器\nwin + r gpedit.msc 选择 计算机配置 -\u0026gt; Windows 设置 -\u0026gt; 安全策略 -\u0026gt; 本地策略 -\u0026gt; 安全选项\n找到下面两项，设置为 禁止\n用户账户控制：以管理员批准模式运行所有管理员 用户账户控制：用于内置管理员账户的管理员批准模式 重新启动后 administator 账户即可获得最高权限\n此方法只适用于 win10 专业版/教育版/企业版","title":"WIN10 获取超级管理员权限"},{"content":"mariadb 修改配置文件\nvim /etc/my.conf.d/server.conf [mysqld] character_set_server=utf8mb4 collation-server=utf8mb4_general_ci init_connect=\u0026#39;SET NAMES utf8mb4\u0026#39; skip-character-set-client-handshake=true 重启 mariadb\nsystemctl restart mariadb 查看编码\nSHOW VARIABLES WHERE Variable_name LIKE \u0026#39;character\\_set\\_%\u0026#39; OR Variable_name LIKE \u0026#39;collation%\u0026#39;; mysql 修改配置文件\nvim /etc/my.cnf [client] default-character-set = utf8mb4 [mysql] default-character-set = utf8mb4 [mysqld] character_set_server=utf8mb4 collation-server=utf8mb4_general_ci init_connect=\u0026#39;SET NAMES utf8mb4\u0026#39; skip-character-set-client-handshake=true 重启 mariadb\nsystemctl restart mysqld 查看编码\nSHOW VARIABLES WHERE Variable_name LIKE \u0026#39;character\\_set\\_%\u0026#39; OR Variable_name LIKE \u0026#39;collation%\u0026#39;; ","permalink":"https://blog.ovenx.cn/post/mysql-utf8mb4/","summary":"mariadb 修改配置文件\nvim /etc/my.conf.d/server.conf [mysqld] character_set_server=utf8mb4 collation-server=utf8mb4_general_ci init_connect=\u0026#39;SET NAMES utf8mb4\u0026#39; skip-character-set-client-handshake=true 重启 mariadb\nsystemctl restart mariadb 查看编码\nSHOW VARIABLES WHERE Variable_name LIKE \u0026#39;character\\_set\\_%\u0026#39; OR Variable_name LIKE \u0026#39;collation%\u0026#39;; mysql 修改配置文件\nvim /etc/my.cnf [client] default-character-set = utf8mb4 [mysql] default-character-set = utf8mb4 [mysqld] character_set_server=utf8mb4 collation-server=utf8mb4_general_ci init_connect=\u0026#39;SET NAMES utf8mb4\u0026#39; skip-character-set-client-handshake=true 重启 mariadb\nsystemctl restart mysqld 查看编码\nSHOW VARIABLES WHERE Variable_name LIKE \u0026#39;character\\_set\\_%\u0026#39; OR Variable_name LIKE \u0026#39;collation%\u0026#39;; ","title":"MySQL 设置默认编码为 utf8mb4"},{"content":"系统版本：Ubuntu-20.04\n配置国内源 修改 source.list\ncp /etc/apt/source.list /etc/apt/source.list.bak vi source.list # 复制下面内容到 source.list deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse 更新源\napt update apt upgrade python3 sudo apt install python-is-python3 nginx apt-get install nginx service nginx start php apt update apt install php php-cli php-fpm php-json php-common php-mysql php-zip php-gd php-mbstring php-curl php-xml php-pear php-bcmath php-dev service php7.4-fpm start redis 安装 redis\napt-get install redis-server apt-get install php-redis 设置密码\nvi /etc/redis/redis.conf # uncomment requirepass 123456 启动 redis\nservice redis-server start swoole 下载安装包\nwget https://github.com/swoole/swoole-src/archive/v4.5.2.tar.gz tar -zxvf v4.5.2.tar.gz 编译\ncd swoole-src-4.5.2 /usr/bin/phpize7.4 ./configure make \u0026amp;\u0026amp; sudo make install 修改 php.ini，/etc/php/7.4/fpm/php.ini\nextension=swoole.so 重启 php-fpm\nservice php7.4-fpm restart docker curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh sudo service docker start node # https://github.com/nodesource/distributions curl -sL https://deb.nodesource.com/setup_current.x | sudo -E bash - sudo apt-get install -y nodejs zsh apt-get install zsh 替换默认 shell\nchsh -s /bin/zsh 安装 oh my zsh\nsh -c \u0026#34;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; 使用主题\nvi ~/.zshrc ZSH_THEME=\u0026#34;agnoster\u0026#34; cd ~ ","permalink":"https://blog.ovenx.cn/post/wsl2-ubuntu/","summary":"系统版本：Ubuntu-20.04\n配置国内源 修改 source.list\ncp /etc/apt/source.list /etc/apt/source.list.bak vi source.list # 复制下面内容到 source.list deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src http://mirrors.","title":"WSL2 Ubuntu 配置"},{"content":"安装 git yum install git git-core 创建 git 用户 为了服务器的安全，一般不会直接使用 root 用户来运行 git 服务。我们可以新建一个 git 用户专门用来执行 git 服务。\n# 添加一个 git 用户 sudo adduser git # 设置密码 passwd git # 禁用shell登录 sudo vi /etc/passwd git: x:1001:1002:,,,:/home/git:/bin/bash # 修改为下面的 git: x:1001:1002:,,,:/home/git:/usr/bin/git-shell 这样，git 用户可以正常通过 ssh 使用 git，但无法登录 shell，因为我们为 git 用户指定的 git-shell每次一登录就自动退出。\n创建证书登录 收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到 /home/git/.ssh/authorized_keys 文件里，一行一个。\n注意 authorized_keys 的权限要设置为 600，.ssh 文件夹设置为 700,没有这个文件的话可以自己创建,注意 .ssh的所有者要为 git:git\n新建 git 仓库 mkdir /opt/git cd /opt/git git init --bare home.git cd /home.git/hooks sudo vi post-receive #写入以下内容 #!/bin/sh GIT_WORK_TREE=/var/www/home git checkout -f # 写入权限 chmod +x post-receive # 文件夹权限 chown -R git:git home.git # 建立web目录，如果目录不存在，git不会创建目录的 mkdir /var/www/home -p # web目录的文件夹权限 chown -R git:git /var/www/home 克隆远程仓库 git clone git@server:/opt/git/home.git Reference 搭建 Git 服务器 使用 Git 来部署一个 Web 站点笔记 ","permalink":"https://blog.ovenx.cn/post/deploy-git/","summary":"安装 git yum install git git-core 创建 git 用户 为了服务器的安全，一般不会直接使用 root 用户来运行 git 服务。我们可以新建一个 git 用户专门用来执行 git 服务。\n# 添加一个 git 用户 sudo adduser git # 设置密码 passwd git # 禁用shell登录 sudo vi /etc/passwd git: x:1001:1002:,,,:/home/git:/bin/bash # 修改为下面的 git: x:1001:1002:,,,:/home/git:/usr/bin/git-shell 这样，git 用户可以正常通过 ssh 使用 git，但无法登录 shell，因为我们为 git 用户指定的 git-shell每次一登录就自动退出。\n创建证书登录 收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到 /home/git/.ssh/authorized_keys 文件里，一行一个。\n注意 authorized_keys 的权限要设置为 600，.ssh 文件夹设置为 700,没有这个文件的话可以自己创建,注意 .ssh的所有者要为 git:git\n新建 git 仓库 mkdir /opt/git cd /opt/git git init --bare home.","title":"Linux 下搭建 git 服务器"},{"content":"前言 之前搭建公司开发环境有一个需求，需要将本地测试服务器中的代码同步推送到线上的服务器。后面开始研究 rsync，中途踩了很多坑，故在此记录下一些主要的操作和注意事项\nRsync 设置 本地同步 同步单个文件\nrsync -avz /etc/passwd /tmp/ # 同步 passwd 文件到 tmp 目录下 同步目录下所有文件（包含目录本身）\nmkdir /root/test1 echo \u0026#34;test1\u0026#34; \u0026gt; /root/test1/file1 rsync -avz /root/test1 /tmp/ # 同步 test1 目录 文件到 tmp 目录下 同步目录下所有文件（不包含目录本身）\nmkdir /root/test2 echo \u0026#34;test\u0026#34; \u0026gt; /root/test2/file2 rsync -avz /root/test2/ /tmp/ # 同步 test2 目录 文件到 tmp 目录下 特别注意后面以 / 结尾不包含目录，没有 / 则包含目录\n通过 SSH 同步到远程服务器 # 本地服务器 echo \u0026#34;test\u0026#34; \u0026gt; /root/rsync_file rsync -avz /root/rsync_file root@remote_ip:/root/rsync_file # 推送到远程服务器 # 也可以指定 key 文件实现免密处理 rsync -avz -e \u0026#34;ssh /rsync/ssh-key\u0026#34; /root/rsync_file root@remote_ip:/root/rsync_file # 远程服务器 cat /root/rsync_file test 使用 ssh 可以实现推送到远程服务器的工作，但是存在很多问题。最主要的一点是 PHP 脚本执行 ssh 时会存在权限的问题。\n使用 Rsync 进程方式传输 这是最常用的使用方式，需要服务端配置运行相应的 rsync 进程\n服务端 首先服务端需要安装 rsync\nyum install rsync -y 编辑配置文件 /etc/rsyncd.cnf\n# 全局配置 uid = rsync gid = rsync port = 873 fake super = yes use chroot = no max connections = 200 timeout = 600 ignore errors read only = false list = false auth users = rsync_backup secrets file = /etc/rsync.password log file = /var/log/rsyncd.log # 模块配置 [test] comment = welcome to rsync! path = /var/www/test 创建虚拟用户\nuseradd -M -s /sbin/nologin rsync 创建备份目录\nmkdir -p /var/www/test/ chown -R rsync.rsync /var/www/test/ 创建虚拟用户密码文件\n# 用户：rsync_backup 密码：123456 echo \u0026#34;rsync_backup:123456\u0026#34; \u0026gt;/etc/rsync.password chmod 600 /etc/rsync.password 启动服务\nsystemctl start rsyncd # 启动服务 systemctl enable rsyncd # 开机启动 netstat -lntp # 检查对应的端口 防火墙设置\nfirewall-cmd --zone=public --add-port=873/tcp --permanent # 开启 873 端口 firewall-cmd --reload # 重启 注意如果服务器是阿里云一定要记得在阿里云的安全策略中加入 873 端口\n客户端 设置密码文件\necho \u0026#34;123456\u0026#34; \u0026gt;/etc/rsync.password # 这里的密码要和服务端保持一致 chmod 600 /etc/rsync.password 开始推送\n# ::test 指的是上面 /etc/rsyncd.conf 中的模块名 # --delete 删除那些 DST 中 SRC 没有的文件 rsync -avz --delete --password-file=/etc/rsync.password /var/www/test/ rsync_backup@remote_ip::test 使用 \u0026ndash;exclude-from 排除不需要同步的目录或文件\nmkdir /etc/rsync vi exclude.list 加入需要排除的文件或文件夹\nruntime/* config/database.php 最终的命令\nrsync -avz --delete --exclude-from=/etc/rsync/exclude.list --password-file=/etc/rsync.password /var/www/test/ rsync_backup@remote_ip::test PHP 调用 Rsync 服务 PHP 配合 Rsync 可以做到指定文件的同步。构建一个同步推送页面，开发人员输入需要同步的文件或者目录，PHP 后端进行批量同步处理。这样做的好处是不需要每次都通过 Linux 命令行来推送代码，多人协作时也更加方便。具体的逻辑我这里就不再描述，核心就是使用 PHP 的 exec 方法执行 Liunx 命令\nexec(\u0026#39;rsync -avz --delete --exclude-from=/etc/rsync/exclude.list --password-file=/etc/rsnyc.password rsync_backup@remote_ip::test 2\u0026gt;\u0026amp;1\u0026#39;, $output, $return_var); ","permalink":"https://blog.ovenx.cn/post/rsync-php/","summary":"前言 之前搭建公司开发环境有一个需求，需要将本地测试服务器中的代码同步推送到线上的服务器。后面开始研究 rsync，中途踩了很多坑，故在此记录下一些主要的操作和注意事项\nRsync 设置 本地同步 同步单个文件\nrsync -avz /etc/passwd /tmp/ # 同步 passwd 文件到 tmp 目录下 同步目录下所有文件（包含目录本身）\nmkdir /root/test1 echo \u0026#34;test1\u0026#34; \u0026gt; /root/test1/file1 rsync -avz /root/test1 /tmp/ # 同步 test1 目录 文件到 tmp 目录下 同步目录下所有文件（不包含目录本身）\nmkdir /root/test2 echo \u0026#34;test\u0026#34; \u0026gt; /root/test2/file2 rsync -avz /root/test2/ /tmp/ # 同步 test2 目录 文件到 tmp 目录下 特别注意后面以 / 结尾不包含目录，没有 / 则包含目录\n通过 SSH 同步到远程服务器 # 本地服务器 echo \u0026#34;test\u0026#34; \u0026gt; /root/rsync_file rsync -avz /root/rsync_file root@remote_ip:/root/rsync_file # 推送到远程服务器 # 也可以指定 key 文件实现免密处理 rsync -avz -e \u0026#34;ssh /rsync/ssh-key\u0026#34; /root/rsync_file root@remote_ip:/root/rsync_file # 远程服务器 cat /root/rsync_file test 使用 ssh 可以实现推送到远程服务器的工作，但是存在很多问题。最主要的一点是 PHP 脚本执行 ssh 时会存在权限的问题。","title":"PHP 配合 Rsync 同步推送代码到服务器"},{"content":"由于国内的网络原因，很多工具（如 npm, pip）等在国内连接很慢，这里整理了下常用的工具国内源\nLinux CentOS 相关地址：http://mirrors.aliyun.com/repo/\n首先备份\nsudo mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak 下载源\n# http://mirrors.aliyun.com/repo/Centos-6.repo # http://mirrors.aliyun.com/repo/Centos-7.repo # http://mirrors.aliyun.com/repo/Centos-8.repo wget http://mirrors.aliyun.com/repo/Centos-8.repo mv Centos-8.repo /etc/yum.repos.d/CentOS-Base.repo 生成缓存\nyum clean all # 清除系统所有的 yum 缓存 yum makecache # 生成 yum 缓存 yum update # 更新 yum Debian 配置国内源\ncp /etc/apt/sources.list /etc/apt/sources.list.bak vi /etc/apt/sources.list # 复制下面内容到 sources.list deb http://mirrors.aliyun.com/debian/ buster main non-free contrib deb-src http://mirrors.aliyun.com/debian/ buster main non-free contrib deb http://mirrors.aliyun.com/debian-security buster/updates main deb-src http://mirrors.aliyun.com/debian-security buster/updates main deb http://mirrors.aliyun.com/debian/ buster-updates main non-free contrib deb-src http://mirrors.aliyun.com/debian/ buster-updates main non-free contrib deb http://mirrors.aliyun.com/debian/ buster-backports main non-free contrib deb-src http://mirrors.aliyun.com/debian/ buster-backports main non-free contrib 更新源\napt update apt upgrade PIP 相关地址：https://developer.aliyun.com/mirror/pypi\n修改配置文件 ~/.pip/pip.conf\n[global] index-url = http://mirrors.aliyun.com/pypi/simple/ [install] trusted-host = mirrors.aliyun.com 也可以直接使用以下命令直接配置\npip config set global.index-url https://mirrors.aliyun.com/pypi/simple/ GO 相关地址：https://goproxy.io/\n设置方法\ngo env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.io,direct Composer 相关地址：https://developer.aliyun.com/composer\ncomposer config -g repo.packagist composer https://mirrors.aliyun.com/composer/ NPM 相关地址：https://developer.aliyun.com/mirror/NPM?from=tnpm\nnpm config set registry https://registry.npm.taobao.org GEM 相关地址： https://gems.ruby-china.com\ngem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/ Docker 登录阿里云 https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors 获取镜像地址 https://xxxxx.mirror.aliyuncs.com 修改 daemon 配置文件 /etc/docker/daemon.json\n{ \u0026#34;registry-mirrors\u0026#34;: [\u0026#34;https://xxxxx.mirror.aliyuncs.com\u0026#34;] } 重启服务\nsudo systemctl daemon-reload sudo systemctl restart docker Site https://developer.aliyun.com/mirror/ http://mirrors.163.com/ https://mirror.tuna.tsinghua.edu.cn/ https://mirrors.ustc.edu.cn/ ","permalink":"https://blog.ovenx.cn/post/china-source/","summary":"由于国内的网络原因，很多工具（如 npm, pip）等在国内连接很慢，这里整理了下常用的工具国内源\nLinux CentOS 相关地址：http://mirrors.aliyun.com/repo/\n首先备份\nsudo mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak 下载源\n# http://mirrors.aliyun.com/repo/Centos-6.repo # http://mirrors.aliyun.com/repo/Centos-7.repo # http://mirrors.aliyun.com/repo/Centos-8.repo wget http://mirrors.aliyun.com/repo/Centos-8.repo mv Centos-8.repo /etc/yum.repos.d/CentOS-Base.repo 生成缓存\nyum clean all # 清除系统所有的 yum 缓存 yum makecache # 生成 yum 缓存 yum update # 更新 yum Debian 配置国内源\ncp /etc/apt/sources.list /etc/apt/sources.list.bak vi /etc/apt/sources.list # 复制下面内容到 sources.list deb http://mirrors.aliyun.com/debian/ buster main non-free contrib deb-src http://mirrors.aliyun.com/debian/ buster main non-free contrib deb http://mirrors.aliyun.com/debian-security buster/updates main deb-src http://mirrors.aliyun.com/debian-security buster/updates main deb http://mirrors.","title":"常用工具国内源配置"},{"content":"本文的环境：\ncentos 7.6 svn 1.7.14 安装 yum install subversion 创建仓库 新建一个名为 test 的代码仓库\nmkdir /var/svn/test svnadmin create /var/svn/test 此时 test 目录的结构如下\ndrwxr-xr-x. 6 root root 86 2月 29 13:13 . drwxrwxrwx. 8 root root 102 3月 9 11:09 .. drwxr-xr-x. 2 root root 54 3月 9 09:24 conf drwxr-sr-x. 6 root root 253 2月 29 13:45 db -r--r--r--. 1 root root 2 2月 29 13:13 format drwxr-xr-x. 2 root root 231 2月 29 14:01 hooks drwxr-xr-x. 2 root root 41 2月 29 13:13 locks -rw-r--r--. 1 root root 229 2月 29 13:13 README.txt 配置 svn 主要涉及配置文件都在 conf 中\npasswd # 密码管理 authz # 权限管理 svnserve.conf # svn服务进程 管理用户（passwd) 用户和密码的格式为 name = password，每行为一个用户，密码为明文。\n添加一个账户名为 test，密码为123456 的用户：\n[users] test = 123456 配置权限 （authz) [groups] # 分组配置 group1 = test group2 = test1, test2 [/] # / 表示整个目录 test = rw # 读写权限 test1 = r # 只有读权限 test2 = w # 只有写权限 @group1 = rw # 分组 group1 内所有用户有读写权限 * = # 其它用户没有任何权限 服务配置（svnserve.conf) 打开下面 4 个注释\nanon-access = read # 匿名用户无权访问 auth-access = write # 认证用户可读写 password-db = passwd # 指定用户认证密码文件 authz-db = authz # 指定权限配置文件 启动服务 # -d 服务后台运行 # -r 指定工作目录 # 注意这里不需要指定到具体哪个仓库 如 /var/svn/test # 如需指定端口可以使用 --listen-port 3691 svnserve -d -r /var/svn 防火墙处理 svn 服务默认的是 3690 端口\nfirewall-cmd --zone=public --add-port=3690/tcp --permanent # 开启 3690 端口 firewall-cmd --reload # 重启 当然也可以直接关闭防火墙，但是不推荐使用\nsystemctl stop firewalld 客户端连接 客户端可以直接使用 svn://ip:3690/test 来 checkout test 仓库，默认端口可以忽略\n配置 hook 自动检出 svn 服务端并不是以原文件来存储的，而是会以特殊的格式（FSFS，BDB）进行版本存储。所以如果我们需要直接在服务器中运行代码程序时需要先 checkout 检出代码，还是以test为例：\n# 把 test 仓库的代码检出到 /var/www/test 目录 svn checkout svn://127.0.0.1/test /var/www/test 但是这样每次检出会很麻烦，使用 svn 的 hook 可以实现自动检出。\n在 /var/svn/test/hooks 目录下新建一个 post-commit 文件，post-commit 文件添加内容为：\n#!/bin/sh EPOS=\u0026#34;$1\u0026#34; # 仓库 REV=\u0026#34;$2\u0026#34; # 版本号 export.UTF-8 # 编码 SVN=/usr/bin/svn # svn WEB=/var/www/test # 要更新的项目目录 $SVN update $WEB --username test --password 1234567 为 post-commit 添加执行权限\nchmod +x /var/project/test/hooks/post-commit commit 限制 默认 svn 提交文件 commit 是没有限制，也就是说可以留空。但通常我们都会限制要求必须填写 commit，以免造成后面的混乱。修改 hook 中的 pre-commit 可以实现 commit 的限制\n首先复制一份 pre-commit 文件\ncp pre-commit.tmpl pre-commit 修改 pre-commit 文件\n#!/bin/sh REPOS=\u0026#34;$1\u0026#34; TXN=\u0026#34;$2\u0026#34; SVNLOOK=/usr/bin/svnlook LOGMSG=`$SVNLOOK log -t \u0026#34;$TXN\u0026#34; \u0026#34;$REPOS\u0026#34; | grep \u0026#34;[a-zA-Z0-9]\u0026#34; | wc -c` if [ \u0026#34;$LOGMSG\u0026#34; -lt 10 ];then echo \u0026#34;提交失败： 注释不能低于10个字符\u0026#34; 1\u0026gt;\u0026amp;2 exit 1 fi 为 pre-commit 添加执行权限\nchmod +x /var/project/test/hooks/pre-commit ","permalink":"https://blog.ovenx.cn/post/linux-svn/","summary":"本文的环境：\ncentos 7.6 svn 1.7.14 安装 yum install subversion 创建仓库 新建一个名为 test 的代码仓库\nmkdir /var/svn/test svnadmin create /var/svn/test 此时 test 目录的结构如下\ndrwxr-xr-x. 6 root root 86 2月 29 13:13 . drwxrwxrwx. 8 root root 102 3月 9 11:09 .. drwxr-xr-x. 2 root root 54 3月 9 09:24 conf drwxr-sr-x. 6 root root 253 2月 29 13:45 db -r--r--r--. 1 root root 2 2月 29 13:13 format drwxr-xr-x. 2 root root 231 2月 29 14:01 hooks drwxr-xr-x.","title":"Linux 下安装 SVN"},{"content":"本文的系统版本 centos7 x64，默认的 python 版本为 2.7，升级之后的版本为 3.8.1\n安装依赖包 yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make yum install libffi-devel # 缺少这个 make 时会报 ModuleNotFound：No module named \u0026#39;_ctypes\u0026#39; 错误 下载源码包 wget https://www.python.org/ftp/python/3.8.1/Python-3.8.1.tgz tar -zxvf Python-3.8.1.tgz 编译 cd Python-3.8.1.tgz ./configure make \u0026amp;\u0026amp; make instal 修改默认 python 及 pip 命令 mv /usr/bin/python /usr/bin/python.bak ln -s /usr/local/bin/python3 /usr/bin/python mv /usr/bin/pip /usr/bin/pip.bak ln -s /usr/local/bin/pip3 /usr/bin/pip 处理 yum 由于 yum 需要使用 python 2.7，如果将默认的 python 修改为 python3 版本就会出现问题，这里需要修改两个地方\nvim /usr/libexec/urlgrabber-ext-down vim /usr/bin/yum 把头部的 /usr/bin/python 修改为 /usr/bin/pyhon2.7\n","permalink":"https://blog.ovenx.cn/post/upgrade-python3/","summary":"本文的系统版本 centos7 x64，默认的 python 版本为 2.7，升级之后的版本为 3.8.1\n安装依赖包 yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make yum install libffi-devel # 缺少这个 make 时会报 ModuleNotFound：No module named \u0026#39;_ctypes\u0026#39; 错误 下载源码包 wget https://www.python.org/ftp/python/3.8.1/Python-3.8.1.tgz tar -zxvf Python-3.8.1.tgz 编译 cd Python-3.8.1.tgz ./configure make \u0026amp;\u0026amp; make instal 修改默认 python 及 pip 命令 mv /usr/bin/python /usr/bin/python.bak ln -s /usr/local/bin/python3 /usr/bin/python mv /usr/bin/pip /usr/bin/pip.bak ln -s /usr/local/bin/pip3 /usr/bin/pip 处理 yum 由于 yum 需要使用 python 2.","title":"Linux 升级 Python3"},{"content":"本文的系统版本 centos7 x64\n查看字体 fc-list 安装字体 cp xxx.ttf /usr/share/fonts/ # copy fonts to /usr/share/fonts 建立字体缓存 cd /usr/share/fonts/ chmod 755 *.ttf # 修改字体权限 mkfontscale # 依赖 mkfonts mkfontdir fc-cache -fv # 依赖 fontconfig ","permalink":"https://blog.ovenx.cn/post/centos-install-fonts/","summary":"本文的系统版本 centos7 x64\n查看字体 fc-list 安装字体 cp xxx.ttf /usr/share/fonts/ # copy fonts to /usr/share/fonts 建立字体缓存 cd /usr/share/fonts/ chmod 755 *.ttf # 修改字体权限 mkfontscale # 依赖 mkfonts mkfontdir fc-cache -fv # 依赖 fontconfig ","title":"CentOS 下安装字体"},{"content":"字母表 A B C D E F G apple body cat dog egg fish girl H I J K L M N hand ice jeep king lamb monkey nose O P Q R S T orange pen queen rabbit snake tiger U V W X Y Z umberlla visa watch x-ray yark zoo 联想 A : 横着的感叹号，左边顶上是一个苹果 B : 一个男孩拿着一个棍子，右边穿了３个糖葫芦 C : 两只猫前后在追各自的玻璃球，猫在左，球在右 D : 狗右边放了两个碟子 E : 一个鸡蛋 F : 金鱼有双尾鳍和一个身体和一个头 G : 一个女汉子拿着一个右边绑了苹果的双节棍 H : 四个握紧的拳头 I : 两个圆筒冰淇淋 J : 前排一个小轮胎，后排有３个大轮胎的jeep车 K : 国王两只手扶着一个皇冠 L : 一条尾巴，一个身体和两个角的羊 M : 两只猴子收尾相接在捞月 N : 感叹号形状的鼻子，上面是圆点 O : 三根橘子味冰棒 P : 两根铅笔组成的船，船头和船尾都坐了一个人 Q : 女王左手双节棍，右手棒棒糖 R : 兔子有两只圆耳朵和一个长方形的脸 S : 一条蟒蛇连续吞了３个鸟蛋 T : 老虎参军站成了笔直的一条线 U : 雨伞左边挂着两个苹果 V : visa卡上有３个编码和一个签名 W : 手表的两条表链都在右边 X : 两个x-ray手枪在对射激光球 Y : 一头有角的公牛在追两头没有角的母牛 Z : Z上下两横，OO两点 规则 Reference https://en.wikipedia.org/wiki/Morse_code\n","permalink":"https://blog.ovenx.cn/post/memorize-morse-code/","summary":"字母表 A B C D E F G apple body cat dog egg fish girl H I J K L M N hand ice jeep king lamb monkey nose O P Q R S T orange pen queen rabbit snake tiger U V W X Y Z umberlla visa watch x-ray yark zoo 联想 A : 横着的感叹号，左边顶上是一个苹果 B : 一个男孩拿着一个棍子，右边穿了３个糖葫芦 C : 两只猫前后在追各自的玻璃球，猫在左，球在右 D : 狗右边放了两个碟子 E : 一个鸡蛋 F : 金鱼有双尾鳍和一个身体和一个头 G : 一个女汉子拿着一个右边绑了苹果的双节棍 H : 四个握紧的拳头 I : 两个圆筒冰淇淋 J : 前排一个小轮胎，后排有３个大轮胎的jeep车 K : 国王两只手扶着一个皇冠 L : 一条尾巴，一个身体和两个角的羊 M : 两只猴子收尾相接在捞月 N : 感叹号形状的鼻子，上面是圆点 O : 三根橘子味冰棒 P : 两根铅笔组成的船，船头和船尾都坐了一个人 Q : 女王左手双节棍，右手棒棒糖 R : 兔子有两只圆耳朵和一个长方形的脸 S : 一条蟒蛇连续吞了３个鸟蛋 T : 老虎参军站成了笔直的一条线 U : 雨伞左边挂着两个苹果 V : visa卡上有３个编码和一个签名 W : 手表的两条表链都在右边 X : 两个x-ray手枪在对射激光球 Y : 一头有角的公牛在追两头没有角的母牛 Z : Z上下两横，OO两点 规则 Reference https://en.","title":"摩尔斯码记忆规则"},{"content":" 在大多数情况下，实际行动都是发生在其主观意义处于模糊的半意识、或者实际上处于无意识的状态中，行动者更有可能是在模模糊糊的意义上“知道”它，但并不明白自己正在干什么或者对它有着明确的自觉意识。 他的行动大多受本能驱使或者习惯使然。只是在偶然的、并且涉及大量同一行动的情况下，往往也只有少数人对于行动的主观意义——无论理性的还是非理性的——产生明确的意识。 完全自觉和明确的有意义行动的理想类型，只能是一种边缘情况，在分析经验事实的时候，任何历史学和社会学的研究都必须考虑到这一点。 ——韦伯《经济与社会》\n拥有强烈自我意识的人永远是少数，甚至是这样的人也在大多数情况下处于无意识或半意识。\n自我意识又是个什么东西呢？就是意识到“自我”的存在。\n情商高与低是由什么决定的？也许有人会说出很多现象和特征，如专注力、自控力、善于交际，但是这些却不能给予你丝毫的帮助。\n因为你只看到了表象——这些由根源的东西衍生出来的外物，然后当你转向其他领域的时候，你一样会困惑。\n一个优秀的人，你所看到的他的优秀只是他的外部而已，你所看不到的是他内在的高度自律和思想的完整秩序。就如同一棵参天大树，你感叹它的奇伟挺拔，你却不知道这棵树的根基扎得有多深多广。当你尝试跟他交流的时候，你才发现，他的知识广博远超乎你的想象，他的见解深刻到你膜拜不已。你会觉得，究竟是怎么的大脑，经过怎样的训练，才能有如此深邃的见识与智慧。\n感受力高的人有更多的自我意识，也就是——他能突然意识到自己的心理变化、过程，从而意识到问题的存在。感受力低的人往往意识不到问题所在，我的意思是说：根本！意识不到！问题所在。\n举个例子：坚持。\n情商高的人更懂坚持，然后呢？你只看到了他无比厉害的外表——然而他怎么坚持下去的？当你实在找不到原因的时候，只能把原因归于“他情商高”。\n问题的关键在于：情商高的人他能注意到坚持过程中自己的负面情绪，从而及时处理这些问题，但是情商低的人他不会注意到这也是一个问题——我，正在讨厌这件事情，这是一个不好的信号，所以，它需要被解决。 你有没有意识到你的情绪，有没有注意到自己的一些想法。\n再举个例子：恋爱。\n恋爱会提升一个人的情商。因为恋爱中的人会时刻小心自己的言行举止，他会进行自我监视，他会关注自我的一言一行以防导致对方对自己失去兴趣：他会去控制好自己的情绪，表现得和平时判若两人，在她面前把各种细节做好\u0026hellip;\u0026hellip;\n最近很红火的《欢乐颂》里有这么一个剧情：一来到公司，安迪就投入到紧张的工作中，开会听报告，等她忙完回到自己的办公室，却发现早已等候在此的老谭。 原来，老谭担心老严带回来的消息会刺激到安迪，便特意带了饭菜到公司陪安迪吃，他表示工作上的事情不用向自己汇报，自己绝对相信安迪，在得知安迪为弟弟的事情满怀愧疚时，老谭表示不管花费多大的人力物力都会帮她找到弟弟。 安迪看着视她如亲人的老谭，十分感动。吃饭的时候有一段Andy的心理特写：Andy第一次发现，老谭心细如发，他记得Andy紧张的时候要靠喝水压制，担心Andy不吃东西，所以亲自作陪，唯恐自己没有朋友、没有亲人，要独自承担一切。 “放心吧，我知道你为什么来，我没事。”\n这就是一个典型的强烈自我意识的例子，她意识到对方为什么而来，对方的心思，对方的考量，如何回馈对方，让对方心安、不要为自己操心，同时享受对方给自己带来的温暖的感觉。 短短的一个情节，充分体现了强烈自我意识者能够清醒快速分析当前情景，并作出正确决策的高情商行为。所以你懂的，为什么五个女主角里，Andy是混得最好的，金领精英阶层代表。\n当然，世事无绝对——并不是每个人都会意识到这一点，有些人谈很多恋爱，还是一样的幼稚。这又是为什么？他感觉很困惑，他觉得是如此的突然，他意识不到有什么问题，他只是跟着感觉走，无意识、无反省。\n再例如：你往往能看到——越是你认为成功的人，他们在生活的各方面都运行良好，这才是真正的人生赢家。我有一种特别的观点，我认为是因为他们具有更多的自我意识，意识到问题所在，生活中的方方面面都需要被关注到——例如，如果健康威胁到了我的情绪，我应该注意到，那么，解决它！\n最后举个例子：自我为中心。\n写作中如何加粗是一个学问：因为你认为你能了解到的东西，人家不一定能有耐心——意识到其中的“自我中心”也是一个问题。一个人会突然意识到，我看到的、感觉到的，和别人是不同的！如何加粗，如何排版，如何使阅读体验最大化，是一个需要被注意到的问题。\n这个世界究竟是怎么样的，不是你头脑认为如何就如何的。那些厉害的人，一定是发现了什么不可告人的认知世界的方式。\n人是思想的产物，心里想的是什么，就会变成什么样的人。 ——甘地\n那么，如何让自我意识为我所用呢？\n我们需要注意一下几个关键性概念：\n自我监视 自我监视（self-monitor）和反思（reflection）不同点在于：自我监视更强调 事中观察——在做事情的时候就意识到，属于及时反馈。 反思是经过一段时间后的整体感知，例如写日记往往在意的是今天印象最深的东西，而无法注意到最细微的当时感受。\n许多顶尖的选手，都是自我监视的有意识或无意识的使用者。 例如下棋、打牌，真正到了国际级别的赛事，心理上的博弈就变得尤为重要，那么留意自己内心的细微想法 ，甚至是无意之中出现的，都非常重要。提升到一定阶段，就会遇到瓶颈，这个瓶颈其实很大程度来源于不知道自己哪里还可以提升 ——越是擅长自我监视的选手，他能看到自己的笨拙，因为他知道他还有那么多的问题需要解决，这种状态是非常令他们享受的。\n自我监视常常容易被事后遗忘，建立一套及时信息记录系统 非常有必要。当我回忆以前中学的一位学霸的时候，她有一个习惯非常值得深思：她常常在路上走着走着就会记录想法，或是考完月考试卷就把一些想法记下来——因为她知道当把月考试卷发回手里的时候，很多感觉就不见了。这些感觉不限于只是针对知识点，还有心态调解，各种方面。\n有时候你会有一种遇到很多次的同样受挫的感觉，每次一到这种境地总是无力解决问题，缺乏自我监视的人会一次次地被类似的感觉仅仅捆住，而懂得自我监视的人学会发现自己正处在了这种情况，那么他通过一两次的成功实验，就能在以后慢慢学会解决。\n没有及时的自我监控，往往就只有事后的后悔与懊恼。\n这个可能大家都有类似的感受了。比如男女朋友吵架了，吵得很厉害，大家互不让步，都没有察觉到自身的错误，然后就导致分手的。事后男方女方都觉得，这件事我确实有不对的地方，但是恶果已酿成，复合已非易事了。\n再比如，领导已在话语中多次暗示你，不要打断我的说话。但是你没意识到，还一个劲地说个不停，话匣子根本关不住，给领导留下非常不好的印象。等别人说完话，有机会自己再表达，这是基本礼貌。如果当场没及时发现领导的意思，事后再发觉，你肯定会懊恼不已。\n作为一个成熟的人，你需要为自己的行为与话语负责，而为了不出差错，你需要保持自我监控，观察自身的思考、感受与情绪等等的变化，也要观察环境、对方的言辞表情等的变化，然后修正处理，才能比较好的 Hold 住全场。\n可视化 关注自己的内心是一种非常抽象的探索，有时候这种感觉只是一道闪光就不见了。只有很少一部分最懂得关注自我的人能把这些体验用图像显现在脑海中，这就是体验的可视化。\n可视化与具体化除了加深理解外，还是经验复制的关键步骤。许多天才都善于抓住一些只可言传不可意会的诀窍，但是他们说不出来，他们只能用一种隐喻（metaphor），或者干脆只能一辈子自己用用。这些模糊而又清晰的感觉，他们在生活中一遍遍地运用，但是他们说不出来。\n这种体验的显化有时候非常抽象，抽象到普通人根本难以理解，而这正是无数人得以成功的秘诀，这种体验的根本来源还是对自我的关注。\n无意识的成功行为转瞬即逝，可视化后的成功可以被个人所领会并加以复制，加以语言化和实体化的成功体验可以被众人所复制。\n悦纳与接受 人天生就有一种让自己只看到自己想看到的东西的本领，选择性过滤也许是自我监视最大的敌人——我们时时刻刻被一些不重要的但困扰着我们的东西所干扰着，但是我们不想也不愿去正视它们。 但是坦然接受一切，再重新审视什么在困扰着你的时候，你也许更能发现问题所在。\n我早期的时候进行了一段时间的自我监视，却总是发现身上的不舒服，坐在凳子上一刻也没舒服的时候，我以为是过度监视导致的神经紧张，于是就停止了一段时间对自我的观察。但后来我发现，这种停止本身就是一种不敢正视问题的表现，于是我重新把自我监视开启，但是这时候的我已经能学会更好的控制自己的意识关注点和进行合理的收放。\n例如，有些人会发现自己在学习的时候容不得噪音，于是他们就会千方百计地寻找安静的地方。但是对自我意识更敏锐和更加接受的人，他们就会倾向于去向这个问题发起更加猛烈的挑战：训练自己在噪声中专注的本领，不仅开大音量， 而且还在各种非常具有吸引注意力的场合，例如在室友打游戏的时候进行高难度的学习。\n在 《学习之道》 中，作者甚至训练出了一种根据这种外界刺激的节奏进行辅助自己思考的能力。例如，我们不仅不回避音乐，还要根据音乐的节奏进行学习，甚至将这些音乐进行知识的编码，成为我们提取知识的一部分。\n刻意练习、实验 当我们发现了内心的冲突的时候，心理问题也许光采取接受的方法就能解决，但是很多高阶的、更加复杂的问题，则需要进行刻意训练。其实刻意练习理论根本上来自于对自我的关注，没有对自我的关注和反馈就永远不可能有提升。\n刻意练习理论需要有最好的教练和最强大的意志力，很多时候我们只是不知道自己处于一种什么样的水平，我们需要什么样的训练，这才是刻意练习最难的地方。\n如果说学习区是刻意练习理论所强调的，那么什么样的感受才是可控而有效的呢？我们只是不知道自己到底该加码还是减轻强度。\nFollow your heart，似乎并不是那么简单的一句话，里面包含着太多的细节。\n联系，一切都在联系之中 一直以来我做事都只完成 30% 或 50%，每次做到最困难的时候我就会不自觉地放弃，瓶颈期太普遍了，所以每次我都会败下阵来，例如摄影、书法、编程、ps\u0026hellip;大学我真的玩过很多东西，但是我觉得没有一件我能坚持很久的事情。这种困扰一直陪伴着我，让我对自己的坚持能力非常担心。\n但是有一天晚上我依旧躺在床上，思索着这个问题，因为我又把一本书只看了一点点。我突然留心到这可能与我“最后阶段的草草行事”有关。我意识到我非常不善于“善终”。我看书的时候，例如看了一会时间，我决定要休息了，我就会迫不及待地把它丢到一边，也没有书签，也没有笔记。更致命的是，我往往看教科书看得七零八落，有时候上课不想听了，就干其他的事情。事情往往是：当时确实是爽了，但之后再想重拾烂摊子就非常拖延和坚持不下去。\n拖延和坚持不下去的根本问题不在于当下，而在于你之前就没把一件事做到非常适合现在去做。最后等你下一次再想去做的时候，记忆的放大效应就会让你非常不想去做，感觉就像一座大山压在面前。\n我真正想到这个的，竟然是我对自己吃饭的关注：我留意到我吃饭最后总要剩下一点饭，因为我觉得压底的饭冷了或是不好吃，我吃菜只吃上面的一层和最好的东西。这体现了我对收尾的极端没有耐心，而正是这种对最后的草草了事导致了下一次开始活动的万般拖延。\n当你进行了对自我的长期关注之后，你就会发现，知识的形式无穷无尽，学习的套路和解决问题的思路却大有想通之处。任何东西都可以成为你解决问题的灵感。\n为什么不同的问题，我们能找到共通的地方？\n因为问题从来都不一样，解决问题时候内心的感受很多时候都是相同的，你模糊地感受到了同样的感觉，就能够指引你从别处找到方法。\n印象画能给人同样的舒畅感，大多数时候是因为他们从心，而不是走形式。\n总之，自我意识是一个成熟的理性人所拥有的最明显和本质的标志。而成长，必然是一个充满顿悟、反惯性、痛苦、枯燥但不乏趣味的自我意识过程。唯有一个意识到问题存在的人才能进步，这是通往成熟和自我完善的门，而自我意识就是这扇门的钥匙。问题，永远是自己思维的问题——你需要更多的自我意识，需要注意到更多的问题。\n不要以为这是一个容易实现的目标，这是一件非常长期的、需要勇气的行为。\n自我意识太强，太敏感了怎么办？我想，一个真正能意识到自己太敏感的人会解决这个问题，但是这里有个更重要的问题：你为什么明知道自己敏感却无法解决这个问题？\n这才是我真正说的自我意识：存在问题？那么，我为什么无法解决它？你有没有意识到问题中的问题？\n我想可能的原因有很多，我猜测其中一个原因是：更多的时候，你并没有把这个当作一个真正的问题去解决。因为人的行为，大部分时间都是按照惯性进行的（这帮助我们快速决策），可是一个只按照惯性行事的人，是没有学习的（学习的真正定义是改变，“改变”发生了学习就在进行之中了）。\n回到问题中，如果你真的有强烈的自我意识，你就会观察自己，搜集数据信息，然后去了解：你在什么情况下敏感？例如，我常常会在和异性交往的过程敏感，这种熟悉的尴尬感觉常常会不期而至，那么，继续观察。继续观察会发现，我为什么会敏感，原因是很多的，这真的不是一个单一问题：说话、着装、经济地位、场合……这些可能都是导致我敏感的因素，那么留心这些东西、熟悉这些东西，为综合分析提供根据。\n一个具有强烈的自我意识的人是敏锐的，却不是敏感的。 前者会在早期注意到这个问题然后去知乎询问，然后坚持改变。我就经历过这个过程，后来我明白：原来敏感，也是可以锻炼的。\n福流（flow）理论认为：当人们进入一种专注的福流状态，自我意识会被暂时省去，人会体验到巨大的投入的快乐，时间会过的很快。那么这是不是意味着自我意识应该被节制地使用呢？\n事实是，自我意识会导致一定的焦虑、痛苦，在积极心理学中，自我意识总是以负面的情绪出现，这不无道理。看看历史中的那些疯掉的天才、作家，再看看卢梭的《忏悔录》，那些数不清的「我」。发生最激烈变革的地方无不是自我意识的主宰战场。\n我希望所有人能在「自我」的道路上走得更远，但也要保持必要的警惕。如果用一句话来表明我现在的观点，我会说：「自我」是通向成功者的道路，但并不是所有的人都想成为成功者，因为那太苦了。\n这里所谈的“自我意识”，与心理学的本我与自我，超我有相类似的地方，可以比照阅读。\n本我与自我，超我共同组成人格。弗洛伊德认为，本我是人格中最早，也是最原始的部分，是生物性冲动和欲望的贮存库。本我是按“唯乐原则”活动的，它不顾一切的要寻求满足和快感，这种快乐特别指性、生理和情感快乐。本我由各种生物本能的能量所构成，完全处于无意识水平中。它是人出生时就有的固着于体内的一切心理积淀物，是被压抑、摈斥于一时之外的人的非理性的、无意识的生命力、内驱力、本能、冲动、欲望等心理能力。\nPS：当你开始刻意培养自己强烈自我意识的时候，这是一个非常有意思的过程。大部分人，都是靠条件反射去应付生活中的大多事，也就是说，控制自己行为和思考的，大部分时候只是本能而已。但是当你尝试去用自我意识，重新把“你”的控制权从本能那里夺过来，这非常有挑战性。你需要发动全身感官，比如视觉去观察，听觉去倾听，有时还得发动嗅觉，触觉等等去获得当前环境的最大化信息，然后运用你的大脑去分析，驾驭你的思考，然后再做出处理。我有几种不同的处理方式，每一种处理方式会导致怎么样的后果。我该选择哪一种，为什么？同时你会察觉到自己的心理与情绪变化，为什么会出现这种变化？如何压制消极的情绪，如何享受积极的情绪等等。这种重新驾驭自己思想、驾驭自我的感觉，非常有意思。\n有时候，当你使用这种监控与驾驭自我的过程中，你会觉得人其实就是一个移动的智能系统，会收集周围环境的数据（信息），通过大脑进行思考处理（利用已有的信息与经验可以更高效准确地处理问题），然后得出决策。与其他移动智能系统之间的交互更有趣，你可以观察对方，思考对方的想法，判断对方说某些话的深意，去读懂对方，倾听对方的经历与故事……等等。在这个过程中，监控自己的思考与心理变化，享受这个驾驭自我的过程，也是一个非常有意思的事。\n你会发现很多成功的人士貌似都会读心术，其实他们是信息获取与思考决策的高手。他们在一瞬间观察并尝试读你，然后几句话就验证他们的判断。这也是他们能够成功的一个重要原因，时刻自我监控，驾驭自己不出差错，同时学习成长。\n当我在笑的时候，我意识到自己在笑，我知道自己很开心，我享受着我笑的那一刻，我认为，这就是人之为人的一个很大的乐趣之一。\n转载自：[[http://www.nowamagic.net/librarys/veda/detail/2824]]\n","permalink":"https://blog.ovenx.cn/post/control-yourself/","summary":"在大多数情况下，实际行动都是发生在其主观意义处于模糊的半意识、或者实际上处于无意识的状态中，行动者更有可能是在模模糊糊的意义上“知道”它，但并不明白自己正在干什么或者对它有着明确的自觉意识。 他的行动大多受本能驱使或者习惯使然。只是在偶然的、并且涉及大量同一行动的情况下，往往也只有少数人对于行动的主观意义——无论理性的还是非理性的——产生明确的意识。 完全自觉和明确的有意义行动的理想类型，只能是一种边缘情况，在分析经验事实的时候，任何历史学和社会学的研究都必须考虑到这一点。 ——韦伯《经济与社会》\n拥有强烈自我意识的人永远是少数，甚至是这样的人也在大多数情况下处于无意识或半意识。\n自我意识又是个什么东西呢？就是意识到“自我”的存在。\n情商高与低是由什么决定的？也许有人会说出很多现象和特征，如专注力、自控力、善于交际，但是这些却不能给予你丝毫的帮助。\n因为你只看到了表象——这些由根源的东西衍生出来的外物，然后当你转向其他领域的时候，你一样会困惑。\n一个优秀的人，你所看到的他的优秀只是他的外部而已，你所看不到的是他内在的高度自律和思想的完整秩序。就如同一棵参天大树，你感叹它的奇伟挺拔，你却不知道这棵树的根基扎得有多深多广。当你尝试跟他交流的时候，你才发现，他的知识广博远超乎你的想象，他的见解深刻到你膜拜不已。你会觉得，究竟是怎么的大脑，经过怎样的训练，才能有如此深邃的见识与智慧。\n感受力高的人有更多的自我意识，也就是——他能突然意识到自己的心理变化、过程，从而意识到问题的存在。感受力低的人往往意识不到问题所在，我的意思是说：根本！意识不到！问题所在。\n举个例子：坚持。\n情商高的人更懂坚持，然后呢？你只看到了他无比厉害的外表——然而他怎么坚持下去的？当你实在找不到原因的时候，只能把原因归于“他情商高”。\n问题的关键在于：情商高的人他能注意到坚持过程中自己的负面情绪，从而及时处理这些问题，但是情商低的人他不会注意到这也是一个问题——我，正在讨厌这件事情，这是一个不好的信号，所以，它需要被解决。 你有没有意识到你的情绪，有没有注意到自己的一些想法。\n再举个例子：恋爱。\n恋爱会提升一个人的情商。因为恋爱中的人会时刻小心自己的言行举止，他会进行自我监视，他会关注自我的一言一行以防导致对方对自己失去兴趣：他会去控制好自己的情绪，表现得和平时判若两人，在她面前把各种细节做好\u0026hellip;\u0026hellip;\n最近很红火的《欢乐颂》里有这么一个剧情：一来到公司，安迪就投入到紧张的工作中，开会听报告，等她忙完回到自己的办公室，却发现早已等候在此的老谭。 原来，老谭担心老严带回来的消息会刺激到安迪，便特意带了饭菜到公司陪安迪吃，他表示工作上的事情不用向自己汇报，自己绝对相信安迪，在得知安迪为弟弟的事情满怀愧疚时，老谭表示不管花费多大的人力物力都会帮她找到弟弟。 安迪看着视她如亲人的老谭，十分感动。吃饭的时候有一段Andy的心理特写：Andy第一次发现，老谭心细如发，他记得Andy紧张的时候要靠喝水压制，担心Andy不吃东西，所以亲自作陪，唯恐自己没有朋友、没有亲人，要独自承担一切。 “放心吧，我知道你为什么来，我没事。”\n这就是一个典型的强烈自我意识的例子，她意识到对方为什么而来，对方的心思，对方的考量，如何回馈对方，让对方心安、不要为自己操心，同时享受对方给自己带来的温暖的感觉。 短短的一个情节，充分体现了强烈自我意识者能够清醒快速分析当前情景，并作出正确决策的高情商行为。所以你懂的，为什么五个女主角里，Andy是混得最好的，金领精英阶层代表。\n当然，世事无绝对——并不是每个人都会意识到这一点，有些人谈很多恋爱，还是一样的幼稚。这又是为什么？他感觉很困惑，他觉得是如此的突然，他意识不到有什么问题，他只是跟着感觉走，无意识、无反省。\n再例如：你往往能看到——越是你认为成功的人，他们在生活的各方面都运行良好，这才是真正的人生赢家。我有一种特别的观点，我认为是因为他们具有更多的自我意识，意识到问题所在，生活中的方方面面都需要被关注到——例如，如果健康威胁到了我的情绪，我应该注意到，那么，解决它！\n最后举个例子：自我为中心。\n写作中如何加粗是一个学问：因为你认为你能了解到的东西，人家不一定能有耐心——意识到其中的“自我中心”也是一个问题。一个人会突然意识到，我看到的、感觉到的，和别人是不同的！如何加粗，如何排版，如何使阅读体验最大化，是一个需要被注意到的问题。\n这个世界究竟是怎么样的，不是你头脑认为如何就如何的。那些厉害的人，一定是发现了什么不可告人的认知世界的方式。\n人是思想的产物，心里想的是什么，就会变成什么样的人。 ——甘地\n那么，如何让自我意识为我所用呢？\n我们需要注意一下几个关键性概念：\n自我监视 自我监视（self-monitor）和反思（reflection）不同点在于：自我监视更强调 事中观察——在做事情的时候就意识到，属于及时反馈。 反思是经过一段时间后的整体感知，例如写日记往往在意的是今天印象最深的东西，而无法注意到最细微的当时感受。\n许多顶尖的选手，都是自我监视的有意识或无意识的使用者。 例如下棋、打牌，真正到了国际级别的赛事，心理上的博弈就变得尤为重要，那么留意自己内心的细微想法 ，甚至是无意之中出现的，都非常重要。提升到一定阶段，就会遇到瓶颈，这个瓶颈其实很大程度来源于不知道自己哪里还可以提升 ——越是擅长自我监视的选手，他能看到自己的笨拙，因为他知道他还有那么多的问题需要解决，这种状态是非常令他们享受的。\n自我监视常常容易被事后遗忘，建立一套及时信息记录系统 非常有必要。当我回忆以前中学的一位学霸的时候，她有一个习惯非常值得深思：她常常在路上走着走着就会记录想法，或是考完月考试卷就把一些想法记下来——因为她知道当把月考试卷发回手里的时候，很多感觉就不见了。这些感觉不限于只是针对知识点，还有心态调解，各种方面。\n有时候你会有一种遇到很多次的同样受挫的感觉，每次一到这种境地总是无力解决问题，缺乏自我监视的人会一次次地被类似的感觉仅仅捆住，而懂得自我监视的人学会发现自己正处在了这种情况，那么他通过一两次的成功实验，就能在以后慢慢学会解决。\n没有及时的自我监控，往往就只有事后的后悔与懊恼。\n这个可能大家都有类似的感受了。比如男女朋友吵架了，吵得很厉害，大家互不让步，都没有察觉到自身的错误，然后就导致分手的。事后男方女方都觉得，这件事我确实有不对的地方，但是恶果已酿成，复合已非易事了。\n再比如，领导已在话语中多次暗示你，不要打断我的说话。但是你没意识到，还一个劲地说个不停，话匣子根本关不住，给领导留下非常不好的印象。等别人说完话，有机会自己再表达，这是基本礼貌。如果当场没及时发现领导的意思，事后再发觉，你肯定会懊恼不已。\n作为一个成熟的人，你需要为自己的行为与话语负责，而为了不出差错，你需要保持自我监控，观察自身的思考、感受与情绪等等的变化，也要观察环境、对方的言辞表情等的变化，然后修正处理，才能比较好的 Hold 住全场。\n可视化 关注自己的内心是一种非常抽象的探索，有时候这种感觉只是一道闪光就不见了。只有很少一部分最懂得关注自我的人能把这些体验用图像显现在脑海中，这就是体验的可视化。\n可视化与具体化除了加深理解外，还是经验复制的关键步骤。许多天才都善于抓住一些只可言传不可意会的诀窍，但是他们说不出来，他们只能用一种隐喻（metaphor），或者干脆只能一辈子自己用用。这些模糊而又清晰的感觉，他们在生活中一遍遍地运用，但是他们说不出来。\n这种体验的显化有时候非常抽象，抽象到普通人根本难以理解，而这正是无数人得以成功的秘诀，这种体验的根本来源还是对自我的关注。\n无意识的成功行为转瞬即逝，可视化后的成功可以被个人所领会并加以复制，加以语言化和实体化的成功体验可以被众人所复制。\n悦纳与接受 人天生就有一种让自己只看到自己想看到的东西的本领，选择性过滤也许是自我监视最大的敌人——我们时时刻刻被一些不重要的但困扰着我们的东西所干扰着，但是我们不想也不愿去正视它们。 但是坦然接受一切，再重新审视什么在困扰着你的时候，你也许更能发现问题所在。\n我早期的时候进行了一段时间的自我监视，却总是发现身上的不舒服，坐在凳子上一刻也没舒服的时候，我以为是过度监视导致的神经紧张，于是就停止了一段时间对自我的观察。但后来我发现，这种停止本身就是一种不敢正视问题的表现，于是我重新把自我监视开启，但是这时候的我已经能学会更好的控制自己的意识关注点和进行合理的收放。\n例如，有些人会发现自己在学习的时候容不得噪音，于是他们就会千方百计地寻找安静的地方。但是对自我意识更敏锐和更加接受的人，他们就会倾向于去向这个问题发起更加猛烈的挑战：训练自己在噪声中专注的本领，不仅开大音量， 而且还在各种非常具有吸引注意力的场合，例如在室友打游戏的时候进行高难度的学习。\n在 《学习之道》 中，作者甚至训练出了一种根据这种外界刺激的节奏进行辅助自己思考的能力。例如，我们不仅不回避音乐，还要根据音乐的节奏进行学习，甚至将这些音乐进行知识的编码，成为我们提取知识的一部分。\n刻意练习、实验 当我们发现了内心的冲突的时候，心理问题也许光采取接受的方法就能解决，但是很多高阶的、更加复杂的问题，则需要进行刻意训练。其实刻意练习理论根本上来自于对自我的关注，没有对自我的关注和反馈就永远不可能有提升。\n刻意练习理论需要有最好的教练和最强大的意志力，很多时候我们只是不知道自己处于一种什么样的水平，我们需要什么样的训练，这才是刻意练习最难的地方。\n如果说学习区是刻意练习理论所强调的，那么什么样的感受才是可控而有效的呢？我们只是不知道自己到底该加码还是减轻强度。\nFollow your heart，似乎并不是那么简单的一句话，里面包含着太多的细节。","title":"重新夺回你自己，做个强烈自我意识的人"},{"content":"本文的环境：\nvue 2.6.11 webpack 4.41.5 babel 7.8.4 node 12.13.1 安装 webpack npm webpack webpack-cli -g 初始化项目 创建目录，初始化 mkdir webpack4-vue2 cd webpack4-vu2 npm init 安装 webpack-dev-server npm install webpack webpack-dev-server --save-dev 新建 webpack.config.js var path = require(\u0026#39;path\u0026#39;); var webpack = require(\u0026#39;webpack\u0026#39;); module.exports = { entry: \u0026#39;./src/main.js\u0026#39;, output: { path: path.resolve(__dirname, \u0026#39;./dist\u0026#39;), publicPath: \u0026#39;/dist/\u0026#39;, filename: \u0026#39;build.js\u0026#39; }, devServer: { historyApiFallback: true, overlay: true }, module: { rules: [] } } 配置 babel babel 的目的是为了将 ES6 转为 ES5 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。参考文档\n首先安装 babel，不同的环境可以 参考文档 npm install @babel/core @babel/preset-env --save-dev 安装 transform-runtime 插件 参考文档 npm install @babel/plugin-transform-runtime --save-dev npm install @babel/runtime --save 项目根目录新建 .babelrc 文件 { \u0026#34;plugins\u0026#34;: [ \u0026#34;@babel/plugin-transform-runtime\u0026#34; ], \u0026#34;presets\u0026#34;: [ \u0026#34;@babel/preset-env\u0026#34; ] } 到这里 babel 基本配置完成，那么在 webpack 中如何使用 babel 呢，我们需要用到 babel-loader，参考文档\n安装 babel-loader npm install babel-loader --save-dev webpack.config.js 添加一个 loader { test: /\\.js$/, loader: \u0026#39;babel-loader\u0026#39;, exclude: /node_modules/ } 配置 vue 安装vue 及相关组件 npm install vue --save npm install vue-loader vue-template-compiler --save-dev npm install node-sass css-loader vue-style-loader sass-loader --save-dev // 解析样式 npm install file-loader --save-dev // 解析静态资源 配置 webpack.config.js，添加相关 loader { test: /\\.css$/, use: [ \u0026#39;vue-style-loader\u0026#39;, \u0026#39;css-loader\u0026#39; ], }, { test: /\\.scss$/, use: [ \u0026#39;vue-style-loader\u0026#39;, \u0026#39;css-loader\u0026#39;, \u0026#39;sass-loader\u0026#39; ], }, { test: /\\.sass$/, use: [ \u0026#39;vue-style-loader\u0026#39;, \u0026#39;css-loader\u0026#39;, \u0026#39;sass-loader?indentedSyntax\u0026#39; ], }, { test: /\\.(png|jpg|gif|svg)$/, loader: \u0026#39;file-loader\u0026#39;, options: { name: \u0026#39;[name].[ext]?[hash]\u0026#39;, esModule: false, publicPath: \u0026#39;../dist/images/\u0026#39;, outputPath: \u0026#39;images/\u0026#39; } }, { test: /\\.(html|htm)$/, use: [ { loader: \u0026#39;html-withimg-loader\u0026#39;, } ] }, { test: /\\.vue$/, loader: \u0026#39;vue-loader\u0026#39;, options: { loaders: { \u0026#39;scss\u0026#39;: [ \u0026#39;vue-style-loader\u0026#39;, \u0026#39;css-loader\u0026#39;, \u0026#39;sass-loader\u0026#39; ], \u0026#39;sass\u0026#39;: [ \u0026#39;vue-style-loader\u0026#39;, \u0026#39;css-loader\u0026#39;, \u0026#39;sass-loader?indentedSyntax\u0026#39; ] } } 配置 webpack.config.js 添加 vue，vue-loader 的支持 const VueLoaderPlugin = require(\u0026#39;vue-loader/lib/plugin\u0026#39;) plugins: [ new VueLoaderPlugin() ], resolve: { alias: { \u0026#39;vue$\u0026#39;: \u0026#39;vue/dist/vue.esm.js\u0026#39; } } 新建文件 src/main.js\nimport Vue from \u0026#39;vue\u0026#39;; import App from \u0026#39;./App.vue\u0026#39;; Vue.config.productionTip = false new Vue({ el: \u0026#39;#app\u0026#39;, template: \u0026#39;\u0026lt;App/\u0026gt;\u0026#39;, components: { App } }) src/App.vue\n\u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;{{ msg }}\u0026lt;/h1\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;msg\u0026#34; /\u0026gt; \u0026lt;img src=\u0026#34;./images/logo.png\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { name: \u0026#34;app\u0026#34;, data() { return { msg: \u0026#34;default text data\u0026#34; }; }, created() { this.getData(); }, methods: { async getData() { const promiseData = function() { return new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#34;changed text data\u0026#34;); }); }; this.msg = await promiseData(); } } }; \u0026lt;/script\u0026gt; \u0026lt;style lang=\u0026#34;scss\u0026#34;\u0026gt; #app { img { margin-top: 20px; width: 200px; } } \u0026lt;/style\u0026gt; src/index.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;webpback4-vue2\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;/dist/build.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 运行 package.json 中添加 script \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;webpack-dev-server --open --hot\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;webpack --progress --hide-modules\u0026#34; }, 运行 npm run dev 打包 npm run build 结束语 以上就是一个简单的webpack4 + vue2 demo项目搭建的全过程。本文仅作参与，如果错误或疏漏，欢迎大家批评指正。源码链接 https://github.com/ovenx/webpack4-vue2\n","permalink":"https://blog.ovenx.cn/post/webpack4-vue2/","summary":"本文的环境：\nvue 2.6.11 webpack 4.41.5 babel 7.8.4 node 12.13.1 安装 webpack npm webpack webpack-cli -g 初始化项目 创建目录，初始化 mkdir webpack4-vue2 cd webpack4-vu2 npm init 安装 webpack-dev-server npm install webpack webpack-dev-server --save-dev 新建 webpack.config.js var path = require(\u0026#39;path\u0026#39;); var webpack = require(\u0026#39;webpack\u0026#39;); module.exports = { entry: \u0026#39;./src/main.js\u0026#39;, output: { path: path.resolve(__dirname, \u0026#39;./dist\u0026#39;), publicPath: \u0026#39;/dist/\u0026#39;, filename: \u0026#39;build.js\u0026#39; }, devServer: { historyApiFallback: true, overlay: true }, module: { rules: [] } } 配置 babel babel 的目的是为了将 ES6 转为 ES5 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。参考文档","title":"搭建 Webpack4 和 Vue2 项目"},{"content":"本文的 python 环境为 python3.8.1\n预览地址：首页 、后台管理\n安装 flask-blog clone 代码到本地\ncd /www git clone https://github.com/ovenx/flask-blog.git 安装虚拟环境\npython -m venv venv . venv/bin/activate 安装依赖\npip install -r requirements.txt 创建数据库,导入数据表\ncreate database flask-blog source /www/flask-blog/blog/schema.sql 创建配置文件，修改数据库配置\ncp /www/flask-blog/blog/config.py.example /www/flask-blog/blog/config.py 使用 gunicorn flask 自带的 server 不能用于生产环境，需要使用其他的 server 替代，一般会使用 gunicorn。\ngunicorn -w4 -b127.0.0.1:8000 run:app // 在venv中启动 此时我们使用了 8000 来访问，替代了原先的端口。-w 表示 worker 数量 -b 表示端口地址。\n到这里其实我们已经可以正常运行 flask-blog 程序了，用 nginx 反代 8000 端口即可。但是 gunicorn 管理起来比较麻烦，为了管理方便我们需要使用 supervisor 来管理 gunicorn 进程。\n使用 supervisor 首先安装 supervisor\npip install supervisor echo_supervisord_conf \u0026gt; /etc/supervisord.conf // 生成配置文件 编辑配置文件 /etc/supervisord.conf，添加 gunicorn\n[program:flask-blog] command=sh -c \u0026#39;source \u0026#34;$0\u0026#34; \u0026amp;\u0026amp; exec \u0026#34;$@\u0026#34;\u0026#39; venv/bin/activate gunicorn -w4 -b 127.0.0.1:8000 run:app directory=/www/flask-blog autostart=true autorestart=true redirect_stderr=true stdout_logfile=/var/log/flask-blog.log stderr_logfile=/var/log/flask-blog.log stopasgroup=true stopsignal=QUIT 这里注意需要先启动 virtualenv\n然后启动 supervisord，默认会启动所有的服务\nsupervisord -c /etc/supervisord.conf //启动 supervisorctl shutdown // 关闭 管理某个服务\nsupervisorctl start flask-blog #启动 supervisorctl stop flask-blog #停止 配置 nginx 反代 创建 /etc/nginx/conf.d/flask-blog.conf，https 配置参考上一篇《let\u0026rsquo;s encrypt 小记》\nserver{ listen 443 http2 ssl; server_name www.domain_1.com; ssl_certificate /etc/letsencrypt/live/www.domain_1.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/www.domain_1.com/privkey.pem; include /etc/nginx/default.d/ssl.conf; location / { proxy_pass http://127.0.0.1:8000; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } } 重启 nginx，大功告成，访问 https://www.domain_1.com/admin 来添加文章吧！\n","permalink":"https://blog.ovenx.cn/post/flask-blog-deploy/","summary":"本文的 python 环境为 python3.8.1\n预览地址：首页 、后台管理\n安装 flask-blog clone 代码到本地\ncd /www git clone https://github.com/ovenx/flask-blog.git 安装虚拟环境\npython -m venv venv . venv/bin/activate 安装依赖\npip install -r requirements.txt 创建数据库,导入数据表\ncreate database flask-blog source /www/flask-blog/blog/schema.sql 创建配置文件，修改数据库配置\ncp /www/flask-blog/blog/config.py.example /www/flask-blog/blog/config.py 使用 gunicorn flask 自带的 server 不能用于生产环境，需要使用其他的 server 替代，一般会使用 gunicorn。\ngunicorn -w4 -b127.0.0.1:8000 run:app // 在venv中启动 此时我们使用了 8000 来访问，替代了原先的端口。-w 表示 worker 数量 -b 表示端口地址。\n到这里其实我们已经可以正常运行 flask-blog 程序了，用 nginx 反代 8000 端口即可。但是 gunicorn 管理起来比较麻烦，为了管理方便我们需要使用 supervisor 来管理 gunicorn 进程。","title":"Flask-blog 部署"},{"content":"前段时间把博客搬家到了 github 上，这里记录下过程。\n安装 hexo npm install hexo hexo init blog cd blog npm install 常用的命令\nhexo new [layout] \u0026lt;title\u0026gt; # 新建文章 hexo g # 生成静态文件 hexo s # 启动服务器 hexo d # 部署网站 hexo d -g # 部署之前预先生成静态文件 github 配置 github 中创建名为 用户名.github.io 的仓库，例如：ovenx.github.io\n配置SSH密钥\nssh-keygen -t rsa -C \u0026#34;your_email@example.com\u0026#34; 把生成后好的 id_ras.pub 文件中的内容复制到 github 中的 SSH keys 设置中\n设置本地 git 的用户信息 git config --global user.name \u0026#34;username\u0026#34; #用户名 git config --global user.email \u0026#34;your_email@example.com\u0026#34; #邮箱 hexo 发布到 github 编辑博客配置文件_config.yml\ndeploy: type: git repo: git@github.com:ovenx/ovenx.github.io.git branch: master 生成静态文件，发布到 github 仓库\nhexo d -g # 部署之前预先生成静态文件 域名配置 创建 CNAME 文件 博客 source 目录中新建 CNAME 文件，里面填入个人的域名如 blog.xiongwentao.me\n配置 DNS\n添加一条 CNAME 记录， 值为 blog 仓库的地址，以 cloudflare 为例：\n| Type | Name | Content | TTL | Proxy status | | ----- | ---- | --------------- | ---- | ------------ | | CNAME | blog | ovenx.github.io | Auto | Proxied | hexo 多端同步 基本的思路就是把博客编译前的内容也同步 github 中，这样随时随地都可以 clone 下来，快速搭建博客\n首页我们需要添加 .gitignore 文件，过滤掉一些不需要的内容\n.DS_Store Thumbs.db db.json *.log node_modules/ public/ .deploy*/ 新建一个 hexo 分支\ngit init git branch hexo git checkout hexo 添加仓库，推送\ngit remote add origin git@github.com:ovenx/ovenx.github.io.git git push origin hexo 运行\ngit checkout master npm install hexo s ","permalink":"https://blog.ovenx.cn/post/hexo-github/","summary":"前段时间把博客搬家到了 github 上，这里记录下过程。\n安装 hexo npm install hexo hexo init blog cd blog npm install 常用的命令\nhexo new [layout] \u0026lt;title\u0026gt; # 新建文章 hexo g # 生成静态文件 hexo s # 启动服务器 hexo d # 部署网站 hexo d -g # 部署之前预先生成静态文件 github 配置 github 中创建名为 用户名.github.io 的仓库，例如：ovenx.github.io\n配置SSH密钥\nssh-keygen -t rsa -C \u0026#34;your_email@example.com\u0026#34; 把生成后好的 id_ras.pub 文件中的内容复制到 github 中的 SSH keys 设置中\n设置本地 git 的用户信息 git config --global user.name \u0026#34;username\u0026#34; #用户名 git config --global user.","title":"Hexo+Github 搭建个人博客"},{"content":"本文的环境是 nginx1.3 + centos7，nginx 设置的根目录 /www\n生成 Diffie-Hellman Parameters 生成这个文件的目的是加强 ssl 的安全性。 当然这一步不是必需的，但是如果没有这一步，网站的 ssl 评级将无法到达 A+。\nsudo openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048 配置 nginx ssl 添加文件 /etc/nginx/default.d/ssl.conf 这里参考 https://cipherli.st/。\nssl_protocols TLSv1.2;# Requires nginx \u0026gt;= 1.13.0 else use TLSv1.2 ssl_prefer_server_ciphers on; ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:DHE-RSA-AES256-SHA; ssl_session_timeout 10m; ssl_session_cache shared:SSL:10m; ssl_session_tickets off; # Requires nginx \u0026gt;= 1.5.9 ssl_stapling on; # Requires nginx \u0026gt;= 1.3.7 ssl_stapling_verify on; # Requires nginx =\u0026gt; 1.3.7 resolver 8.8.8.8 8.8.4.4 valid=300s; resolver_timeout 5s; add_header Strict-Transport-Security \u0026#34;max-age=63072000; includeSubDomains; preload\u0026#34;; add_header X-Frame-Options DENY; add_header X-Content-Type-Options nosniff; add_header X-XSS-Protection \u0026#34;1; mode=block\u0026#34;; add_header X-Robots-Tag none; 如果上一步生成了 dhparam.pem，需要加上\nssl_dhparam /etc/ssl/certs/dhparam.pem; 添加文件 /etc/nginx/default.d/letsencrypt.conf\nlocation /.well-known/acme-challenge { root /www/letsencrypt; } 创建 ssl 认证的目录\nsudo mkdir -p /www/letsencrypt/.well-known/acme-challenge 配置 nginx http 这一步主要是为了在生成证书时，验证 /www/letsencrypt\nserver { server_name www.domain_1.com; listen 80; listen [::]:80; include /etc/nginx/default.d/letsencrypt.conf; location / { try_files $uri $uri/ =404; } } 安装 certbot sudo yum install certbot 使用 certbot 生成证书 certbot certonly --cert-name domain.com --webroot -w /www/letsencrypt -d www.domain_1.com -d wwww.domain_2.com 查看证书 certbot certificates 删除证书 certbot delete --cert-name domain.com 配置 nginx https 添加文件 /etc/nginx/config.d/domain_1.conf，其中指定了上一步生成的证书位置\nserver { server_name www.domain_1.com; listen 443 http2 ssl default_server; listen [::]:443 http2 ssl default_server; ssl_certificate /etc/letsencrypt/live/www.domain_1.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/www.domain_1.com/privkey.pem; include /etc/nginx/default.d/ssl.conf; root /www; index index.html; location / { try_files $uri $uri/ =404; } } # redirect to https server { server_name www.domain_1.com; listen 80; listen [::]:80; include /etc/nginx/default.d/letsencrypt.conf; location / { return 301 https://$host$request_uri; } } 自动更新证书 Certbot 可以更新 30 天内期限的证书，测试更新可以使用\ncertbot renew --dry-run 更方便的做法是设置 crontab 来自动更新证书，先编写一个脚本/root/letsencrypt.sh\n#!/bin/bash systemctl reload nginx 然后编写 crontab，certbot 更新完成后会自动完成调用 letsencrypt.sh 重启 nginx\n20 03 * * * certbot renew --quiet --deploy-hook /root/letsencrypt.sh ","permalink":"https://blog.ovenx.cn/post/lets-encrypt/","summary":"本文的环境是 nginx1.3 + centos7，nginx 设置的根目录 /www\n生成 Diffie-Hellman Parameters 生成这个文件的目的是加强 ssl 的安全性。 当然这一步不是必需的，但是如果没有这一步，网站的 ssl 评级将无法到达 A+。\nsudo openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048 配置 nginx ssl 添加文件 /etc/nginx/default.d/ssl.conf 这里参考 https://cipherli.st/。\nssl_protocols TLSv1.2;# Requires nginx \u0026gt;= 1.13.0 else use TLSv1.2 ssl_prefer_server_ciphers on; ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:DHE-RSA-AES256-SHA; ssl_session_timeout 10m; ssl_session_cache shared:SSL:10m; ssl_session_tickets off; # Requires nginx \u0026gt;= 1.5.9 ssl_stapling on; # Requires nginx \u0026gt;= 1.3.7 ssl_stapling_verify on; # Requires nginx =\u0026gt; 1.3.7 resolver 8.8.8.8 8.8.4.4 valid=300s; resolver_timeout 5s; add_header Strict-Transport-Security \u0026#34;max-age=63072000; includeSubDomains; preload\u0026#34;; add_header X-Frame-Options DENY; add_header X-Content-Type-Options nosniff; add_header X-XSS-Protection \u0026#34;1; mode=block\u0026#34;; add_header X-Robots-Tag none; 如果上一步生成了 dhparam.","title":"Let's Encrypt 小记"}]